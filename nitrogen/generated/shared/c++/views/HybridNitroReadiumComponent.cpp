///
/// HybridNitroReadiumComponent.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "HybridNitroReadiumComponent.hpp"

#include <string>
#include <exception>
#include <utility>
#include <NitroModules/NitroDefines.hpp>
#include <NitroModules/JSIConverter.hpp>
#include <react/renderer/core/RawValue.h>
#include <react/renderer/core/ShadowNode.h>
#include <react/renderer/core/ComponentDescriptor.h>
#include <react/renderer/components/view/ViewProps.h>

namespace margelo::nitro::nitroreadium::views {

  extern const char HybridNitroReadiumComponentName[] = "NitroReadium";

  HybridNitroReadiumProps::HybridNitroReadiumProps(const react::PropsParserContext& context,
                                                   const HybridNitroReadiumProps& sourceProps,
                                                   const react::RawProps& rawProps):
    react::ViewProps(context, sourceProps, rawProps, filterObjectKeys),
    nitroSource([&]() -> CachedProp<NitroFileSource> {
      try {
        const react::RawValue* rawValue = rawProps.at("nitroSource", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.nitroSource;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<NitroFileSource>::fromRawValue(*runtime, value, sourceProps.nitroSource);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.nitroSource: ") + exc.what());
      }
    }()),
    locator([&]() -> CachedProp<std::optional<Locator>> {
      try {
        const react::RawValue* rawValue = rawProps.at("locator", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.locator;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<Locator>>::fromRawValue(*runtime, value, sourceProps.locator);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.locator: ") + exc.what());
      }
    }()),
    preferences([&]() -> CachedProp<std::optional<EpubPreferences>> {
      try {
        const react::RawValue* rawValue = rawProps.at("preferences", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.preferences;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<EpubPreferences>>::fromRawValue(*runtime, value, sourceProps.preferences);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.preferences: ") + exc.what());
      }
    }()),
    decorations([&]() -> CachedProp<std::optional<std::vector<Decoration>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("decorations", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.decorations;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::vector<Decoration>>>::fromRawValue(*runtime, value, sourceProps.decorations);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.decorations: ") + exc.what());
      }
    }()),
    injectedJavascriptOnResourcesLoad([&]() -> CachedProp<std::optional<std::string>> {
      try {
        const react::RawValue* rawValue = rawProps.at("injectedJavascriptOnResourcesLoad", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.injectedJavascriptOnResourcesLoad;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::string>>::fromRawValue(*runtime, value, sourceProps.injectedJavascriptOnResourcesLoad);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.injectedJavascriptOnResourcesLoad: ") + exc.what());
      }
    }()),
    injectedJavascriptOnPageLoad([&]() -> CachedProp<std::optional<std::string>> {
      try {
        const react::RawValue* rawValue = rawProps.at("injectedJavascriptOnPageLoad", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.injectedJavascriptOnPageLoad;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::string>>::fromRawValue(*runtime, value, sourceProps.injectedJavascriptOnPageLoad);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.injectedJavascriptOnPageLoad: ") + exc.what());
      }
    }()),
    turnPageOnTap([&]() -> CachedProp<std::optional<bool>> {
      try {
        const react::RawValue* rawValue = rawProps.at("turnPageOnTap", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.turnPageOnTap;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<bool>>::fromRawValue(*runtime, value, sourceProps.turnPageOnTap);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.turnPageOnTap: ") + exc.what());
      }
    }()),
    onLocatorChanged([&]() -> CachedProp<std::optional<std::function<void(const Locator& /* locator */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onLocatorChanged", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onLocatorChanged;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const Locator& /* locator */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onLocatorChanged);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onLocatorChanged: ") + exc.what());
      }
    }()),
    onSelection([&]() -> CachedProp<std::optional<std::function<void(const std::optional<Selection>& /* selection */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onSelection", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onSelection;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const std::optional<Selection>& /* selection */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onSelection);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onSelection: ") + exc.what());
      }
    }()),
    onDecorationActivated([&]() -> CachedProp<std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onDecorationActivated", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onDecorationActivated;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onDecorationActivated);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onDecorationActivated: ") + exc.what());
      }
    }()),
    onTap([&]() -> CachedProp<std::optional<std::function<void(const TapEvent& /* event */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onTap", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onTap;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const TapEvent& /* event */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onTap);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onTap: ") + exc.what());
      }
    }()),
    onDrag([&]() -> CachedProp<std::optional<std::function<void(const DragEvent& /* event */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onDrag", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onDrag;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const DragEvent& /* event */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onDrag);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onDrag: ") + exc.what());
      }
    }()),
    onPageChanged([&]() -> CachedProp<std::optional<std::function<void(double /* page */, double /* totalPages */, const Locator& /* locator */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onPageChanged", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onPageChanged;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(double /* page */, double /* totalPages */, const Locator& /* locator */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onPageChanged);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onPageChanged: ") + exc.what());
      }
    }()),
    onPageLoaded([&]() -> CachedProp<std::optional<std::function<void()>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onPageLoaded", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onPageLoaded;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void()>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onPageLoaded);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onPageLoaded: ") + exc.what());
      }
    }()),
    onPreferencesChanged([&]() -> CachedProp<std::optional<std::function<void(const EpubPreferences& /* preferences */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onPreferencesChanged", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onPreferencesChanged;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const EpubPreferences& /* preferences */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onPreferencesChanged);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onPreferencesChanged: ") + exc.what());
      }
    }()),
    onMessage([&]() -> CachedProp<std::optional<std::function<void(const std::string& /* message */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("onMessage", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.onMessage;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const std::string& /* message */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.onMessage);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.onMessage: ") + exc.what());
      }
    }()),
    hybridRef([&]() -> CachedProp<std::optional<std::function<void(const std::shared_ptr<margelo::nitro::nitroreadium::HybridNitroReadiumSpec>& /* ref */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("hybridRef", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.hybridRef;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const std::shared_ptr<margelo::nitro::nitroreadium::HybridNitroReadiumSpec>& /* ref */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.hybridRef);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroReadium.hybridRef: ") + exc.what());
      }
    }()) { }

  HybridNitroReadiumProps::HybridNitroReadiumProps(const HybridNitroReadiumProps& other):
    react::ViewProps(),
    nitroSource(other.nitroSource),
    locator(other.locator),
    preferences(other.preferences),
    decorations(other.decorations),
    injectedJavascriptOnResourcesLoad(other.injectedJavascriptOnResourcesLoad),
    injectedJavascriptOnPageLoad(other.injectedJavascriptOnPageLoad),
    turnPageOnTap(other.turnPageOnTap),
    onLocatorChanged(other.onLocatorChanged),
    onSelection(other.onSelection),
    onDecorationActivated(other.onDecorationActivated),
    onTap(other.onTap),
    onDrag(other.onDrag),
    onPageChanged(other.onPageChanged),
    onPageLoaded(other.onPageLoaded),
    onPreferencesChanged(other.onPreferencesChanged),
    onMessage(other.onMessage),
    hybridRef(other.hybridRef) { }

  bool HybridNitroReadiumProps::filterObjectKeys(const std::string& propName) {
    switch (hashString(propName)) {
      case hashString("nitroSource"): return true;
      case hashString("locator"): return true;
      case hashString("preferences"): return true;
      case hashString("decorations"): return true;
      case hashString("injectedJavascriptOnResourcesLoad"): return true;
      case hashString("injectedJavascriptOnPageLoad"): return true;
      case hashString("turnPageOnTap"): return true;
      case hashString("onLocatorChanged"): return true;
      case hashString("onSelection"): return true;
      case hashString("onDecorationActivated"): return true;
      case hashString("onTap"): return true;
      case hashString("onDrag"): return true;
      case hashString("onPageChanged"): return true;
      case hashString("onPageLoaded"): return true;
      case hashString("onPreferencesChanged"): return true;
      case hashString("onMessage"): return true;
      case hashString("hybridRef"): return true;
      default: return false;
    }
  }

  HybridNitroReadiumComponentDescriptor::HybridNitroReadiumComponentDescriptor(const react::ComponentDescriptorParameters& parameters)
    : ConcreteComponentDescriptor(parameters,
                                  react::RawPropsParser(/* enableJsiParser */ true)) {}

  react::Props::Shared HybridNitroReadiumComponentDescriptor::cloneProps(const react::PropsParserContext& context,
                                                                         const react::Props::Shared& props,
                                                                         react::RawProps rawProps) const {
    // 1. Prepare raw props parser
    rawProps.parse(rawPropsParser_);
    // 2. Copy props with Nitro's cached copy constructor
    return HybridNitroReadiumShadowNode::Props(context, /* & */ rawProps, props);
  }

#ifdef ANDROID
  void HybridNitroReadiumComponentDescriptor::adopt(react::ShadowNode& shadowNode) const {
    // This is called immediately after `ShadowNode` is created, cloned or in progress.
    // On Android, we need to wrap props in our state, which gets routed through Java and later unwrapped in JNI/C++.
    auto& concreteShadowNode = dynamic_cast<HybridNitroReadiumShadowNode&>(shadowNode);
    const HybridNitroReadiumProps& props = concreteShadowNode.getConcreteProps();
    HybridNitroReadiumState state;
    state.setProps(props);
    concreteShadowNode.setStateData(std::move(state));
  }
#endif

} // namespace margelo::nitro::nitroreadium::views
