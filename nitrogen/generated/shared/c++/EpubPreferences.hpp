///
/// EpubPreferences.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `ColumnCount` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ColumnCount; }
// Forward declaration of `ImageFilter` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ImageFilter; }
// Forward declaration of `ReadingProgression` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ReadingProgression; }
// Forward declaration of `Spread` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class Spread; }
// Forward declaration of `TextAlign` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class TextAlign; }
// Forward declaration of `Theme` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class Theme; }

#include <optional>
#include <string>
#include "ColumnCount.hpp"
#include "ImageFilter.hpp"
#include "ReadingProgression.hpp"
#include "Spread.hpp"
#include "TextAlign.hpp"
#include "Theme.hpp"

namespace margelo::nitro::nitroreadium {

  /**
   * A struct which can be represented as a JavaScript object (EpubPreferences).
   */
  struct EpubPreferences {
  public:
    std::optional<std::string> backgroundColor     SWIFT_PRIVATE;
    std::optional<ColumnCount> columnCount     SWIFT_PRIVATE;
    std::optional<std::string> fontFamily     SWIFT_PRIVATE;
    std::optional<double> fontSize     SWIFT_PRIVATE;
    std::optional<double> fontWeight     SWIFT_PRIVATE;
    std::optional<bool> hyphens     SWIFT_PRIVATE;
    std::optional<ImageFilter> imageFilter     SWIFT_PRIVATE;
    std::optional<std::string> language     SWIFT_PRIVATE;
    std::optional<double> letterSpacing     SWIFT_PRIVATE;
    std::optional<bool> ligatures     SWIFT_PRIVATE;
    std::optional<double> lineHeight     SWIFT_PRIVATE;
    std::optional<double> pageMargins     SWIFT_PRIVATE;
    std::optional<double> paragraphIndent     SWIFT_PRIVATE;
    std::optional<double> paragraphSpacing     SWIFT_PRIVATE;
    std::optional<bool> publisherStyles     SWIFT_PRIVATE;
    std::optional<ReadingProgression> readingProgression     SWIFT_PRIVATE;
    std::optional<bool> scroll     SWIFT_PRIVATE;
    std::optional<Spread> spread     SWIFT_PRIVATE;
    std::optional<TextAlign> textAlign     SWIFT_PRIVATE;
    std::optional<std::string> textColor     SWIFT_PRIVATE;
    std::optional<bool> textNormalization     SWIFT_PRIVATE;
    std::optional<Theme> theme     SWIFT_PRIVATE;
    std::optional<double> typeScale     SWIFT_PRIVATE;
    std::optional<bool> verticalText     SWIFT_PRIVATE;
    std::optional<double> wordSpacing     SWIFT_PRIVATE;

  public:
    EpubPreferences() = default;
    explicit EpubPreferences(std::optional<std::string> backgroundColor, std::optional<ColumnCount> columnCount, std::optional<std::string> fontFamily, std::optional<double> fontSize, std::optional<double> fontWeight, std::optional<bool> hyphens, std::optional<ImageFilter> imageFilter, std::optional<std::string> language, std::optional<double> letterSpacing, std::optional<bool> ligatures, std::optional<double> lineHeight, std::optional<double> pageMargins, std::optional<double> paragraphIndent, std::optional<double> paragraphSpacing, std::optional<bool> publisherStyles, std::optional<ReadingProgression> readingProgression, std::optional<bool> scroll, std::optional<Spread> spread, std::optional<TextAlign> textAlign, std::optional<std::string> textColor, std::optional<bool> textNormalization, std::optional<Theme> theme, std::optional<double> typeScale, std::optional<bool> verticalText, std::optional<double> wordSpacing): backgroundColor(backgroundColor), columnCount(columnCount), fontFamily(fontFamily), fontSize(fontSize), fontWeight(fontWeight), hyphens(hyphens), imageFilter(imageFilter), language(language), letterSpacing(letterSpacing), ligatures(ligatures), lineHeight(lineHeight), pageMargins(pageMargins), paragraphIndent(paragraphIndent), paragraphSpacing(paragraphSpacing), publisherStyles(publisherStyles), readingProgression(readingProgression), scroll(scroll), spread(spread), textAlign(textAlign), textColor(textColor), textNormalization(textNormalization), theme(theme), typeScale(typeScale), verticalText(verticalText), wordSpacing(wordSpacing) {}
  };

} // namespace margelo::nitro::nitroreadium

namespace margelo::nitro {

  using namespace margelo::nitro::nitroreadium;

  // C++ EpubPreferences <> JS EpubPreferences (object)
  template <>
  struct JSIConverter<EpubPreferences> final {
    static inline EpubPreferences fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return EpubPreferences(
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "backgroundColor")),
        JSIConverter<std::optional<ColumnCount>>::fromJSI(runtime, obj.getProperty(runtime, "columnCount")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "fontFamily")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "fontSize")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "fontWeight")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "hyphens")),
        JSIConverter<std::optional<ImageFilter>>::fromJSI(runtime, obj.getProperty(runtime, "imageFilter")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "language")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "letterSpacing")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "ligatures")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "lineHeight")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "pageMargins")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "paragraphIndent")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "paragraphSpacing")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "publisherStyles")),
        JSIConverter<std::optional<ReadingProgression>>::fromJSI(runtime, obj.getProperty(runtime, "readingProgression")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "scroll")),
        JSIConverter<std::optional<Spread>>::fromJSI(runtime, obj.getProperty(runtime, "spread")),
        JSIConverter<std::optional<TextAlign>>::fromJSI(runtime, obj.getProperty(runtime, "textAlign")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "textColor")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "textNormalization")),
        JSIConverter<std::optional<Theme>>::fromJSI(runtime, obj.getProperty(runtime, "theme")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "typeScale")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "verticalText")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "wordSpacing"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const EpubPreferences& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "backgroundColor", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.backgroundColor));
      obj.setProperty(runtime, "columnCount", JSIConverter<std::optional<ColumnCount>>::toJSI(runtime, arg.columnCount));
      obj.setProperty(runtime, "fontFamily", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.fontFamily));
      obj.setProperty(runtime, "fontSize", JSIConverter<std::optional<double>>::toJSI(runtime, arg.fontSize));
      obj.setProperty(runtime, "fontWeight", JSIConverter<std::optional<double>>::toJSI(runtime, arg.fontWeight));
      obj.setProperty(runtime, "hyphens", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.hyphens));
      obj.setProperty(runtime, "imageFilter", JSIConverter<std::optional<ImageFilter>>::toJSI(runtime, arg.imageFilter));
      obj.setProperty(runtime, "language", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.language));
      obj.setProperty(runtime, "letterSpacing", JSIConverter<std::optional<double>>::toJSI(runtime, arg.letterSpacing));
      obj.setProperty(runtime, "ligatures", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.ligatures));
      obj.setProperty(runtime, "lineHeight", JSIConverter<std::optional<double>>::toJSI(runtime, arg.lineHeight));
      obj.setProperty(runtime, "pageMargins", JSIConverter<std::optional<double>>::toJSI(runtime, arg.pageMargins));
      obj.setProperty(runtime, "paragraphIndent", JSIConverter<std::optional<double>>::toJSI(runtime, arg.paragraphIndent));
      obj.setProperty(runtime, "paragraphSpacing", JSIConverter<std::optional<double>>::toJSI(runtime, arg.paragraphSpacing));
      obj.setProperty(runtime, "publisherStyles", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.publisherStyles));
      obj.setProperty(runtime, "readingProgression", JSIConverter<std::optional<ReadingProgression>>::toJSI(runtime, arg.readingProgression));
      obj.setProperty(runtime, "scroll", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.scroll));
      obj.setProperty(runtime, "spread", JSIConverter<std::optional<Spread>>::toJSI(runtime, arg.spread));
      obj.setProperty(runtime, "textAlign", JSIConverter<std::optional<TextAlign>>::toJSI(runtime, arg.textAlign));
      obj.setProperty(runtime, "textColor", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.textColor));
      obj.setProperty(runtime, "textNormalization", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.textNormalization));
      obj.setProperty(runtime, "theme", JSIConverter<std::optional<Theme>>::toJSI(runtime, arg.theme));
      obj.setProperty(runtime, "typeScale", JSIConverter<std::optional<double>>::toJSI(runtime, arg.typeScale));
      obj.setProperty(runtime, "verticalText", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.verticalText));
      obj.setProperty(runtime, "wordSpacing", JSIConverter<std::optional<double>>::toJSI(runtime, arg.wordSpacing));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "backgroundColor"))) return false;
      if (!JSIConverter<std::optional<ColumnCount>>::canConvert(runtime, obj.getProperty(runtime, "columnCount"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "fontFamily"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "fontSize"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "fontWeight"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "hyphens"))) return false;
      if (!JSIConverter<std::optional<ImageFilter>>::canConvert(runtime, obj.getProperty(runtime, "imageFilter"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "language"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "letterSpacing"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "ligatures"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "lineHeight"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "pageMargins"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "paragraphIndent"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "paragraphSpacing"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "publisherStyles"))) return false;
      if (!JSIConverter<std::optional<ReadingProgression>>::canConvert(runtime, obj.getProperty(runtime, "readingProgression"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "scroll"))) return false;
      if (!JSIConverter<std::optional<Spread>>::canConvert(runtime, obj.getProperty(runtime, "spread"))) return false;
      if (!JSIConverter<std::optional<TextAlign>>::canConvert(runtime, obj.getProperty(runtime, "textAlign"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "textColor"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "textNormalization"))) return false;
      if (!JSIConverter<std::optional<Theme>>::canConvert(runtime, obj.getProperty(runtime, "theme"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "typeScale"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "verticalText"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "wordSpacing"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
