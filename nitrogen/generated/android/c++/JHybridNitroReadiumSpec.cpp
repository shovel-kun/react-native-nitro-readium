///
/// JHybridNitroReadiumSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridNitroReadiumSpec.hpp"

// Forward declaration of `NitroFileSource` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct NitroFileSource; }
// Forward declaration of `Locator` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Locator; }
// Forward declaration of `Locations` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Locations; }
// Forward declaration of `TextObject` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct TextObject; }
// Forward declaration of `EpubPreferences` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct EpubPreferences; }
// Forward declaration of `ColumnCount` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ColumnCount; }
// Forward declaration of `ImageFilter` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ImageFilter; }
// Forward declaration of `ReadingProgression` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class ReadingProgression; }
// Forward declaration of `Spread` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class Spread; }
// Forward declaration of `TextAlign` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class TextAlign; }
// Forward declaration of `Theme` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class Theme; }
// Forward declaration of `Decoration` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Decoration; }
// Forward declaration of `DecorationStyle` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct DecorationStyle; }
// Forward declaration of `DecorationType` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class DecorationType; }
// Forward declaration of `Selection` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Selection; }
// Forward declaration of `Rect` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Rect; }
// Forward declaration of `DecorationActivatedEvent` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct DecorationActivatedEvent; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct Point; }
// Forward declaration of `TapEvent` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct TapEvent; }
// Forward declaration of `DragEvent` to properly resolve imports.
namespace margelo::nitro::nitroreadium { struct DragEvent; }
// Forward declaration of `DragEventType` to properly resolve imports.
namespace margelo::nitro::nitroreadium { enum class DragEventType; }

#include "NitroFileSource.hpp"
#include "JNitroFileSource.hpp"
#include <string>
#include <optional>
#include "Locator.hpp"
#include "JLocator.hpp"
#include "Locations.hpp"
#include "JLocations.hpp"
#include <vector>
#include "TextObject.hpp"
#include "JTextObject.hpp"
#include "EpubPreferences.hpp"
#include "JEpubPreferences.hpp"
#include "ColumnCount.hpp"
#include "JColumnCount.hpp"
#include "ImageFilter.hpp"
#include "JImageFilter.hpp"
#include "ReadingProgression.hpp"
#include "JReadingProgression.hpp"
#include "Spread.hpp"
#include "JSpread.hpp"
#include "TextAlign.hpp"
#include "JTextAlign.hpp"
#include "Theme.hpp"
#include "JTheme.hpp"
#include "Decoration.hpp"
#include "JDecoration.hpp"
#include "DecorationStyle.hpp"
#include "JDecorationStyle.hpp"
#include "DecorationType.hpp"
#include "JDecorationType.hpp"
#include <functional>
#include "JFunc_void_Locator.hpp"
#include "Selection.hpp"
#include "JFunc_void_std__optional_Selection_.hpp"
#include "JSelection.hpp"
#include "Rect.hpp"
#include "JRect.hpp"
#include "DecorationActivatedEvent.hpp"
#include "JFunc_void_DecorationActivatedEvent.hpp"
#include "JDecorationActivatedEvent.hpp"
#include "Point.hpp"
#include "JPoint.hpp"
#include "TapEvent.hpp"
#include "JFunc_void_TapEvent.hpp"
#include "JTapEvent.hpp"
#include "DragEvent.hpp"
#include "JFunc_void_DragEvent.hpp"
#include "JDragEvent.hpp"
#include "DragEventType.hpp"
#include "JDragEventType.hpp"
#include "JFunc_void_double_double_Locator.hpp"
#include "JFunc_void.hpp"
#include "JFunc_void_std__string.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/JPromise.hpp>

namespace margelo::nitro::nitroreadium {

  jni::local_ref<JHybridNitroReadiumSpec::jhybriddata> JHybridNitroReadiumSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridNitroReadiumSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridNitroReadiumSpec::initHybrid),
    });
  }

  size_t JHybridNitroReadiumSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  // Properties
  NitroFileSource JHybridNitroReadiumSpec::getNitroSource() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JNitroFileSource>()>("getNitroSource");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridNitroReadiumSpec::setNitroSource(const NitroFileSource& nitroSource) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JNitroFileSource> /* nitroSource */)>("setNitroSource");
    method(_javaPart, JNitroFileSource::fromCpp(nitroSource));
  }
  std::optional<Locator> JHybridNitroReadiumSpec::getLocator() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JLocator>()>("getLocator");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setLocator(const std::optional<Locator>& locator) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JLocator> /* locator */)>("setLocator");
    method(_javaPart, locator.has_value() ? JLocator::fromCpp(locator.value()) : nullptr);
  }
  std::optional<EpubPreferences> JHybridNitroReadiumSpec::getPreferences() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JEpubPreferences>()>("getPreferences");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setPreferences(const std::optional<EpubPreferences>& preferences) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JEpubPreferences> /* preferences */)>("setPreferences");
    method(_javaPart, preferences.has_value() ? JEpubPreferences::fromCpp(preferences.value()) : nullptr);
  }
  std::optional<std::vector<Decoration>> JHybridNitroReadiumSpec::getDecorations() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JDecoration>>()>("getDecorations");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<Decoration> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setDecorations(const std::optional<std::vector<Decoration>>& decorations) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JDecoration>> /* decorations */)>("setDecorations");
    method(_javaPart, decorations.has_value() ? [&]() {
      size_t __size = decorations.value().size();
      jni::local_ref<jni::JArrayClass<JDecoration>> __array = jni::JArrayClass<JDecoration>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = decorations.value()[__i];
        __array->setElement(__i, *JDecoration::fromCpp(__element));
      }
      return __array;
    }() : nullptr);
  }
  std::optional<std::string> JHybridNitroReadiumSpec::getInjectedJavascriptOnResourcesLoad() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getInjectedJavascriptOnResourcesLoad");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setInjectedJavascriptOnResourcesLoad(const std::optional<std::string>& injectedJavascriptOnResourcesLoad) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* injectedJavascriptOnResourcesLoad */)>("setInjectedJavascriptOnResourcesLoad");
    method(_javaPart, injectedJavascriptOnResourcesLoad.has_value() ? jni::make_jstring(injectedJavascriptOnResourcesLoad.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroReadiumSpec::getInjectedJavascriptOnPageLoad() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getInjectedJavascriptOnPageLoad");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setInjectedJavascriptOnPageLoad(const std::optional<std::string>& injectedJavascriptOnPageLoad) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* injectedJavascriptOnPageLoad */)>("setInjectedJavascriptOnPageLoad");
    method(_javaPart, injectedJavascriptOnPageLoad.has_value() ? jni::make_jstring(injectedJavascriptOnPageLoad.value()) : nullptr);
  }
  std::optional<std::function<void(const Locator& /* locator */)>> JHybridNitroReadiumSpec::getOnLocatorChanged() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_Locator::javaobject>()>("getOnLocatorChanged_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const Locator& /* locator */)> {
      if (__result->isInstanceOf(JFunc_void_Locator_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_Locator_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](Locator locator) -> void {
          return __result->invoke(locator);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnLocatorChanged(const std::optional<std::function<void(const Locator& /* locator */)>>& onLocatorChanged) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_Locator::javaobject> /* onLocatorChanged */)>("setOnLocatorChanged_cxx");
    method(_javaPart, onLocatorChanged.has_value() ? JFunc_void_Locator_cxx::fromCpp(onLocatorChanged.value()) : nullptr);
  }
  std::optional<std::function<void(const std::optional<Selection>& /* selection */)>> JHybridNitroReadiumSpec::getOnSelection() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_std__optional_Selection_::javaobject>()>("getOnSelection_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const std::optional<Selection>& /* selection */)> {
      if (__result->isInstanceOf(JFunc_void_std__optional_Selection__cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_std__optional_Selection__cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](std::optional<Selection> selection) -> void {
          return __result->invoke(selection);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnSelection(const std::optional<std::function<void(const std::optional<Selection>& /* selection */)>>& onSelection) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_std__optional_Selection_::javaobject> /* onSelection */)>("setOnSelection_cxx");
    method(_javaPart, onSelection.has_value() ? JFunc_void_std__optional_Selection__cxx::fromCpp(onSelection.value()) : nullptr);
  }
  std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>> JHybridNitroReadiumSpec::getOnDecorationActivated() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_DecorationActivatedEvent::javaobject>()>("getOnDecorationActivated_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const DecorationActivatedEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_DecorationActivatedEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_DecorationActivatedEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](DecorationActivatedEvent event) -> void {
          return __result->invoke(event);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnDecorationActivated(const std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>& onDecorationActivated) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_DecorationActivatedEvent::javaobject> /* onDecorationActivated */)>("setOnDecorationActivated_cxx");
    method(_javaPart, onDecorationActivated.has_value() ? JFunc_void_DecorationActivatedEvent_cxx::fromCpp(onDecorationActivated.value()) : nullptr);
  }
  std::optional<std::function<void(const TapEvent& /* event */)>> JHybridNitroReadiumSpec::getOnTap() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_TapEvent::javaobject>()>("getOnTap_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const TapEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_TapEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_TapEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](TapEvent event) -> void {
          return __result->invoke(event);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnTap(const std::optional<std::function<void(const TapEvent& /* event */)>>& onTap) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_TapEvent::javaobject> /* onTap */)>("setOnTap_cxx");
    method(_javaPart, onTap.has_value() ? JFunc_void_TapEvent_cxx::fromCpp(onTap.value()) : nullptr);
  }
  std::optional<std::function<void(const DragEvent& /* event */)>> JHybridNitroReadiumSpec::getOnDrag() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_DragEvent::javaobject>()>("getOnDrag_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const DragEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_DragEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_DragEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](DragEvent event) -> void {
          return __result->invoke(event);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnDrag(const std::optional<std::function<void(const DragEvent& /* event */)>>& onDrag) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_DragEvent::javaobject> /* onDrag */)>("setOnDrag_cxx");
    method(_javaPart, onDrag.has_value() ? JFunc_void_DragEvent_cxx::fromCpp(onDrag.value()) : nullptr);
  }
  std::optional<std::function<void(double /* page */, double /* totalPages */, const Locator& /* locator */)>> JHybridNitroReadiumSpec::getOnPageChanged() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_double_double_Locator::javaobject>()>("getOnPageChanged_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(double /* page */, double /* totalPages */, const Locator& /* locator */)> {
      if (__result->isInstanceOf(JFunc_void_double_double_Locator_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_double_double_Locator_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](double page, double totalPages, Locator locator) -> void {
          return __result->invoke(page,totalPages,locator);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnPageChanged(const std::optional<std::function<void(double /* page */, double /* totalPages */, const Locator& /* locator */)>>& onPageChanged) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_double_double_Locator::javaobject> /* onPageChanged */)>("setOnPageChanged_cxx");
    method(_javaPart, onPageChanged.has_value() ? JFunc_void_double_double_Locator_cxx::fromCpp(onPageChanged.value()) : nullptr);
  }
  std::optional<std::function<void()>> JHybridNitroReadiumSpec::getOnPageLoaded() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>()>("getOnPageLoaded_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result]() -> void {
          return __result->invoke();
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnPageLoaded(const std::optional<std::function<void()>>& onPageLoaded) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* onPageLoaded */)>("setOnPageLoaded_cxx");
    method(_javaPart, onPageLoaded.has_value() ? JFunc_void_cxx::fromCpp(onPageLoaded.value()) : nullptr);
  }
  std::optional<std::function<void(const std::string& /* message */)>> JHybridNitroReadiumSpec::getOnMessage() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_std__string::javaobject>()>("getOnMessage_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const std::string& /* message */)> {
      if (__result->isInstanceOf(JFunc_void_std__string_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_std__string_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        return [__result](std::string message) -> void {
          return __result->invoke(message);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroReadiumSpec::setOnMessage(const std::optional<std::function<void(const std::string& /* message */)>>& onMessage) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_std__string::javaobject> /* onMessage */)>("setOnMessage_cxx");
    method(_javaPart, onMessage.has_value() ? JFunc_void_std__string_cxx::fromCpp(onMessage.value()) : nullptr);
  }

  // Methods
  std::shared_ptr<Promise<std::optional<std::string>>> JHybridNitroReadiumSpec::evaluateJavascript(const std::string& script) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* script */)>("evaluateJavascript");
    auto __result = method(_javaPart, jni::make_jstring(script));
    return [&]() {
      auto __promise = Promise<std::optional<std::string>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridNitroReadiumSpec::injectJavascript(const std::string& script) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* script */)>("injectJavascript");
    method(_javaPart, jni::make_jstring(script));
  }
  void JHybridNitroReadiumSpec::go(const Locator& locator) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JLocator> /* locator */)>("go");
    method(_javaPart, JLocator::fromCpp(locator));
  }
  void JHybridNitroReadiumSpec::clearSelection() {
    static const auto method = javaClassStatic()->getMethod<void()>("clearSelection");
    method(_javaPart);
  }

} // namespace margelo::nitro::nitroreadium
