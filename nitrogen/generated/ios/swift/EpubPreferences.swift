///
/// EpubPreferences.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `EpubPreferences`, backed by a C++ struct.
 */
public typealias EpubPreferences = margelo.nitro.nitroreadium.EpubPreferences

public extension EpubPreferences {
  private typealias bridge = margelo.nitro.nitroreadium.bridge.swift

  /**
   * Create a new instance of `EpubPreferences`.
   */
  init(backgroundColor: String?, columnCount: ColumnCount?, fontFamily: String?, fontSize: Double?, fontWeight: Double?, hyphens: Bool?, imageFilter: ImageFilter?, language: String?, letterSpacing: Double?, ligatures: Bool?, lineHeight: Double?, pageMargins: Double?, paragraphIndent: Double?, paragraphSpacing: Double?, publisherStyles: Bool?, readingProgression: ReadingProgression?, scroll: Bool?, spread: Spread?, textAlign: TextAlign?, textColor: String?, textNormalization: Bool?, theme: Theme?, typeScale: Double?, verticalText: Bool?, wordSpacing: Double?) {
    self.init({ () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = backgroundColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_ColumnCount_ in
      if let __unwrappedValue = columnCount {
        return bridge.create_std__optional_ColumnCount_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = fontFamily {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = fontSize {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = fontWeight {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = hyphens {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_ImageFilter_ in
      if let __unwrappedValue = imageFilter {
        return bridge.create_std__optional_ImageFilter_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = language {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = letterSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = ligatures {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = lineHeight {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = pageMargins {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = paragraphIndent {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = paragraphSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = publisherStyles {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_ReadingProgression_ in
      if let __unwrappedValue = readingProgression {
        return bridge.create_std__optional_ReadingProgression_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = scroll {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_Spread_ in
      if let __unwrappedValue = spread {
        return bridge.create_std__optional_Spread_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_TextAlign_ in
      if let __unwrappedValue = textAlign {
        return bridge.create_std__optional_TextAlign_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = textColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = textNormalization {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_Theme_ in
      if let __unwrappedValue = theme {
        return bridge.create_std__optional_Theme_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = typeScale {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = verticalText {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = wordSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  var backgroundColor: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__backgroundColor.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__backgroundColor = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var columnCount: ColumnCount? {
    @inline(__always)
    get {
      return self.__columnCount.value
    }
    @inline(__always)
    set {
      self.__columnCount = { () -> bridge.std__optional_ColumnCount_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_ColumnCount_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var fontFamily: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__fontFamily.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__fontFamily = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var fontSize: Double? {
    @inline(__always)
    get {
      return self.__fontSize.value
    }
    @inline(__always)
    set {
      self.__fontSize = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var fontWeight: Double? {
    @inline(__always)
    get {
      return self.__fontWeight.value
    }
    @inline(__always)
    set {
      self.__fontWeight = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var hyphens: Bool? {
    @inline(__always)
    get {
      return self.__hyphens.value
    }
    @inline(__always)
    set {
      self.__hyphens = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var imageFilter: ImageFilter? {
    @inline(__always)
    get {
      return self.__imageFilter.value
    }
    @inline(__always)
    set {
      self.__imageFilter = { () -> bridge.std__optional_ImageFilter_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_ImageFilter_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var language: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__language.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__language = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var letterSpacing: Double? {
    @inline(__always)
    get {
      return self.__letterSpacing.value
    }
    @inline(__always)
    set {
      self.__letterSpacing = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var ligatures: Bool? {
    @inline(__always)
    get {
      return self.__ligatures.value
    }
    @inline(__always)
    set {
      self.__ligatures = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var lineHeight: Double? {
    @inline(__always)
    get {
      return self.__lineHeight.value
    }
    @inline(__always)
    set {
      self.__lineHeight = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var pageMargins: Double? {
    @inline(__always)
    get {
      return self.__pageMargins.value
    }
    @inline(__always)
    set {
      self.__pageMargins = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var paragraphIndent: Double? {
    @inline(__always)
    get {
      return self.__paragraphIndent.value
    }
    @inline(__always)
    set {
      self.__paragraphIndent = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var paragraphSpacing: Double? {
    @inline(__always)
    get {
      return self.__paragraphSpacing.value
    }
    @inline(__always)
    set {
      self.__paragraphSpacing = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var publisherStyles: Bool? {
    @inline(__always)
    get {
      return self.__publisherStyles.value
    }
    @inline(__always)
    set {
      self.__publisherStyles = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var readingProgression: ReadingProgression? {
    @inline(__always)
    get {
      return self.__readingProgression.value
    }
    @inline(__always)
    set {
      self.__readingProgression = { () -> bridge.std__optional_ReadingProgression_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_ReadingProgression_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var scroll: Bool? {
    @inline(__always)
    get {
      return self.__scroll.value
    }
    @inline(__always)
    set {
      self.__scroll = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var spread: Spread? {
    @inline(__always)
    get {
      return self.__spread.value
    }
    @inline(__always)
    set {
      self.__spread = { () -> bridge.std__optional_Spread_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_Spread_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var textAlign: TextAlign? {
    @inline(__always)
    get {
      return self.__textAlign.value
    }
    @inline(__always)
    set {
      self.__textAlign = { () -> bridge.std__optional_TextAlign_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_TextAlign_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var textColor: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__textColor.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__textColor = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var textNormalization: Bool? {
    @inline(__always)
    get {
      return self.__textNormalization.value
    }
    @inline(__always)
    set {
      self.__textNormalization = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var theme: Theme? {
    @inline(__always)
    get {
      return self.__theme.value
    }
    @inline(__always)
    set {
      self.__theme = { () -> bridge.std__optional_Theme_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_Theme_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var typeScale: Double? {
    @inline(__always)
    get {
      return self.__typeScale.value
    }
    @inline(__always)
    set {
      self.__typeScale = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var verticalText: Bool? {
    @inline(__always)
    get {
      return self.__verticalText.value
    }
    @inline(__always)
    set {
      self.__verticalText = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var wordSpacing: Double? {
    @inline(__always)
    get {
      return self.__wordSpacing.value
    }
    @inline(__always)
    set {
      self.__wordSpacing = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
}
